@import controllers.QueryControllerUtil
@import com.github.kaeluka.spencer.tracefiles._
@*
* This template takes a single argument, a String containing a
* message to display.
*@
@(dbname: String, klass: Option[String], idx: Long, log: AproposData, source: Option[String])

@*
* Call the `main` template with two arguments. The first
* argument is a `String` with the title of the page, the second
* argument is an `Html` object containing the body of the page.
*@
@main("Apropos "+idx) {

    @*
    * Get an `Html` object by calling the built-in Play welcome
    * template and passing a `String` message.
    * @play20.welcome(message, style = "Scala")
    *@
    <h2>Apropos @dbname :: @idx</h2>

    <script>
        var COMMAND = "apropos";
        var DBNAME  = "@dbname";
        var QUERIES = ["Set("+@idx+")"];
    </script>

    <ul>
        <li><a class="largehint" href='@routes.QueryController.query(dbname, s"Set($idx)")'>Set(@idx) - construct object query.</a></li>
    </ul>

    <h2>here:</h2>
    <div class="aproposHistory"></div>

    <script>
        let HISTORY = {
            oid: @idx,
            klass: "@log.klass",
            threadHistories: {}
        };

        @for(thd: String <- log.evts.map(AproposEvent.getThread(_)).toSet) {
        //@thd
        HISTORY.threadHistories["@thd"] = [];
        }

        function insertCallIntoThreadHistory(thdHistory, call) {
            let N = thdHistory.length;
            if (N == 0) {
                call['innerHistory'] = [];
                thdHistory.push(call);
            } else {
                let idx=N-1;
                while (thdHistory[idx].start > call.start && idx >= 0) {
                    idx--;
                }
                if (idx == -1) {
                    call['innerHistory'] = [];
                    thdHistory.splice(0,0,call);
                } else {
                    if (thdHistory[idx].end > call.end) {
                        insertCallIntoThreadHistory(thdHistory[idx].innerHistory, call);
                    } else {
                        call['innerHistory'] = [];
                        thdHistory.splice(idx+1,0,call)
                    }
                }
//                if (thdHistory[N-1].end > call.end) {
//                    insertCallIntoThreadHistory(thdHistory[N-1].innerHistory, call);
//                } else {
//                    call['innerHistory'] = [];
//                    thdHistory.push(call);
//                }
            }
        }

        function insertUseIntoThreadHistory(thdHistory, use) {
//            if (use.start == 477358) {
//                debugger;
//            }
            let call = thdHistory.find(function (call) {
                return call.type === "call" && call.start < use.start && call.end > use.start;
            });
            if (call) {
                insertUseIntoThreadHistory(call.innerHistory, use);
            } else {
                let firstLaterIdx = thdHistory.findIndex(function (itm) {
                    return itm.start > use.start;
                });
                if (firstLaterIdx >= 0) {
//                    console.log({splicing_into: thdHistory, at: i});
                    thdHistory.splice(firstLaterIdx, 0, use);
//                    console.log({spliced: thdHistory});
                } else {
                    if (thdHistory.length == 0) {
                        thdHistory.splice(0,0,use);
                    } else {
                        thdHistory.push(use);
                    }
                }
            }
        }

        @for(evt: AproposEvent <- log.evts
             .filter(_.isInstanceOf[AproposCallEvent])
             .asInstanceOf[Seq[AproposCallEvent]]
             .sortBy(AproposEvent.startTime(_))) {
            insertCallIntoThreadHistory(
                    HISTORY.threadHistories["@AproposEvent.getThread(evt)"],
                    @Html(AproposEvent.toJSON(evt)));
        }

        @for(evt: AproposEvent <- log.evts
             .filter(e => e.isInstanceOf[AproposUseEvent] || e.isInstanceOf[AproposRefEvent])
             .sortBy(AproposEvent.startTime)) {
        insertUseIntoThreadHistory(
                HISTORY.threadHistories["@AproposEvent.getThread(evt)"],
                @Html(AproposEvent.toJSON(evt)));
        }

        console.log({HISTORY});

        let threads = [];
        for (let thread in HISTORY.threadHistories) {
            threads.push(thread);
        }

        let aproposHistory =d3.select(".aproposHistory");

        let threadDivs = aproposHistory
                .selectAll("div")
                .data(threads)
                .enter()
                .append("div");

        threadDivs
                .append("h3")
                .attr("class", "code")
                .html(function (d,i) {
                    return d;
                });

        let callsDiv = threadDivs
                .append("div")
                .attr("class", "callsDiv");

        let layer = callsDiv
                .selectAll("div")
                .data(function (d, i) {
                    return HISTORY.threadHistories[d];
                }).enter()
                .append("div")
                .attr("class", "call");

        function makeCallStructure(parents) {
            console.log({parents});
            parents
                    .append("span")
                    .html(function (d, i) {
                        console.log({d});
                        if (d.type === "call") {
                            let caller = (d.caller == @idx) ? "calling " : "<span class='oid'>" + d.caller + "</span> calls ";
                            let callee = (d.callee == @idx) ? "<span class='code'>this</span>" : "<span class='oid'>" + d.callee + "</span>";
                            let name = "<span class='code'>."+d.name.replace(/</, "&lt;").replace(/>/, "&gt;") + "<span>";
                            let loc = "<span class='callsite'>"+d.callsite+"</span>";
                            let time = "<span class='evtidx'>"+d.start + "</span>";
                            return time + ": " + caller + callee + name + "(..) at " + loc + "<br/>";
                        } else if (d.type === "use") {
                            if (d.start == 2314523) {
                                console.log({here_it_is: d});
                            }
                            let caller = (d.caller == @idx) ? "" : "<span class='oid'>" + d.caller + "</span> executes ";
                            let kind = d.kind.replace(/</, "&lt;").replace(/>/, "&gt;")+" of ";
                            let callee = (d.callee == @idx) ? "<span class='code'>this</span>" : "<span class='oid'>" + d.callee + "</span>";
                            let name = "<span class='code'>."+d.name.replace(/</, "&lt;").replace(/>/, "&gt;") + "<span>";
                            let time = "<span class='evtidx'>" + d.start + "</span>";
                            return time+": "+caller+kind+callee+name;
                        } else if (d.type === "ref") {
                            let time = "<span class='evtidx'>" + d.start + "</span>";
                            let name = "<span class='code'>." + d.name.replace(/</, "&lt;").replace(/>/, "&gt;") + "<span> ";
                            let lifetime = " (alive until <span class='evtidx'>" + d.end + "</span>)";
                            if (d.callee == @idx) {
                                let caller = (d.caller == @idx) ? "from <span class='code'>this</span> " : "from <span class='oid'>" + d.caller + "</span> ";
                                let callee = "to <span class='code'>this</span> ";
                                return time + ":  new " + d.kind + " ref " + caller + name + callee + lifetime;
                            } else {
                                let caller = (d.caller == @idx) ? "from <span class='code'>this</span> " : "from <span class='oid'>" + d.caller + "</span> ";
                                let callee = "to <span class='oid'>" + d.callee + "</span>";
                                return time + ":  new " + d.kind + " ref " + caller + name + callee + lifetime;
                            }
                        } else {
                            return "some "+d.type+'<br/>';
                        }
                    });

            let children = parents.selectAll("div")
                    .data(function (d) {
                        if (d.innerHistory) {
                            return d.innerHistory;
                        } else {
                            return [];
                        }
                    }).enter().append("div").attr("class", "call");
            if (children.size() > 0) {
                makeCallStructure(children);
            }
        }

        makeCallStructure(layer);

    </script>


    <div class="bytecode">
        @Html(source match {
            case Some(src) =>
                "<h2>Source for " + klass.getOrElse("BUG: unknown klass name") + "</h2>" +
                        "<pre>\n" +
                        src +
                        "</pre>"
            case None => "(no source available)"
        })
    </div>
}

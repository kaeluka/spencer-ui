@import com.github.kaeluka.spencer.analysis.QueryParser
@import com.github.kaeluka.spencer.tracefiles.SpencerDB
@()(implicit db: SpencerDB)
@*
 * Call the `main` template with two arguments. The first
 * argument is a `String` with the title of the page, the second
 * argument is an `Html` object containing the body of the page.
 *@
@main("Welcome to Spencer") {

    @*
     * Get an `Html` object by calling the built-in Play welcome
     * template and passing a `String` message.
     * @play20.welcome(message, style = "Scala")
     *@

    <img height="200px" alt="Spencer" src="@routes.Assets.versioned("images/spencer.jpg")"/>

    <div class="text">
        <h1>Spencer, Tracing as a Service</h1>

        Spencer is a tool to analyse large program traces using custom queries.
        Queries in spencer are composable: If you have one analysis, you are
        able to refine it using others.

        <h2>Queries</h2>
        Queries in Spencer are expressions that return a set of object IDs. They
        implement a test: does an object's lifetime fulfill a certain definition or
        not?

        Spencer distinguishes between primitive queries and composed queries.
        Primitive queries are the basic building blocks that are implemented
        "natively" in the backend of the service.

        The primitive queries are:

        <style>
            table thead tr {
                background-color: #ebdaa9;
            }

            table {
                margin-top: 2em;
                margin-bottom: 2em;
                margin-left: auto;
                margin-right: auto;
            }
        </style>

        <script>
            var DBNAME='test';
        </script>

        <table class="queries">
            <thead>
                <tr>
                    <td>Query</td>
                    <td>Meaning</td>
                </tr>
            </thead>
            <tbody>
            @for(q <- QueryParser.primitiveQueries()) {
                <tr>
                    <td><div class="query">@q.toString</div></td>
                    <td><span class="queryExplanation">All objects that @(q.explanation) .</span></td>
                </tr>
            }
            </tbody>
        </table>

        Spencer's power lies in the fact that these queries all return the same
        kind of structure: sets of objects! This restriction makes it possible
        to compose queries into larger ones, like so:

        <table class="queries">
            <thead>
                <tr>
                    <td>Query</td>
                    <td>Meaning</td>
                </tr>
            </thead>
            <tbody>
            @for(q <- List(
                "And(ImmutableObj() AllocatedAt(String.java:1933))",
                "Or(UniqueObj() ImmutableObj())",
                "ReachableFrom(AllocatedAt(String.java:1933))",
                "CanReach(AllocatedAt(String.java:1933))"
            )
                    .map(QueryParser.parseObjQuery)
                    .map(x => { assert(x.isRight, x+" must be right!"); x.right.get })) {
                <tr>
                    <td><div class="query">@q.toString</div></td>
                    <td><span class="queryExplanation">All objects that @(q.explanation).</span></td>
                </tr>
            }
            </tbody>
        </table>

        <h2>The design of Queries</h2>

        <h2>What's in the data?</h2>

        Spencer contains data sets. One data set is a program trace (in preprocessed form) that
        stems from running and instrumenting a program.

        The data in the program are distributed over several tables:

        <h3>The <span class="code">objects</span> table</h3>

        <table>
            <thead>
                <tr>
                    <td>object id</td>
                    <td>allocation site file</td>
                    <td>event idx of allocation </td>
                    <td>event idx of last usage</td>
                </tr>
            </thead>
            <tbody>
                @for(rec <- db.getTable("objects").filter(_.getLong("id") > 1500).take(15).sortBy(_.getLong("id"))) {
                    <tr>
                        <td><span class="oid">@rec.getLong("id")</span></td>
                        <td>
                            @((rec.getStringOption("allocationsitefile"), rec.getLongOption("allocationsiteline")) match {
                                case (Some(f), Some(l)) => Html("<span class='allocationsite'>"+f+":"+l+"</span>")
                                case _ => Html("<span class='empty'>none</span>")
                            })
                        </td>
                        <td><span class="evtidx">@rec.getLong("firstusage")</span></td>
                        <td><span class="evtidx">@rec.getLong("lastusage")</span></td>
                    </tr>
                }
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
            </tbody>

        </table>

        <h3>The <span class="code">refs</span> table</h3>

        <table>
            <thead>
                <tr>
                    <td>holder of reference</td>
                    <td>referent</td>
                    <td>kind of reference</td>
                    <td>name of reference</td>
                    <td>start of reference</td>
                    <td>end of reference (if any)</td>
                    <td>thread that establish the reference</td>
                </tr>
            </thead>
            <tbody>
                @for(rec <- db.getTable("refs").filter(_.getLong("caller") > 1500).take(15).sortBy(_.getLong("start"))) {
                    <tr>
                        <td><span class="oid">@rec.getLong("caller")</span></td>
                        <td><span class="oid">@rec.getLong("callee")</span></td>
                        <td><span class="code">@rec.getString("kind")</span></td>
                        <td><span class="code">@rec.getString("name")</span></td>
                        <td><span class="evtidx">@rec.getLong("start")</span></td>
                        <td>@Html(rec.getLongOption("end").map("<span class='evtidx'>"+_+"</span>").getOrElse("<span class='empty'>none</span>"))</td>
                        <td><span class="code">@rec.getString("thread")</span></td>
                    </tr>
                }
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
            </tbody>

        </table>

        <h3>The <span class="code">uses</span> table</h3>

        <h3>Sequence</h3>

        <h3>Graph</h3>



        <h1>Examples</h1>


        <ul>
            <li><a href='@routes.QueryController.perobj("test", "MutableObj()" )'>All mutable objects</a></li>
            <li><a href='@routes.QueryController.perobj("test", "ImmutableObj()")'>All immutable objects</a></li>
            <li><a href='@routes.QueryController.perobj("test", "Deeply(ImmutableObj())")'>All deeply immutable objects</a></li>
            <li><a href='@routes.QueryController.perobj("test", "CanReach(Set(6641 7458))")'>All objects that can reach (transitively, via fields) either object 6641 or 7458</a></li>
        </ul>
    </div>

}

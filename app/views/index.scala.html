@import com.github.kaeluka.spencer.analysis.QueryParser
@import com.github.kaeluka.spencer.analysis.SpencerDB
@import org.apache.spark.sql.functions._

@()(implicit db: SpencerDB)
@*
 * Call the `main` template with two arguments. The first
 * argument is a `String` with the title of the page, the second
 * argument is an `Html` object containing the body of the page.
 *@
@main("Welcome to Spencer") {

    @*
     * Get an `Html` object by calling the built-in Play welcome
     * template and passing a `String` message.
     * @play20.welcome(message, style = "Scala")
     *@

    <div class="text">

        <h1><img height="100px" alt="Spencer" src="@routes.Assets.versioned("images/spencer_logo_bright.svg")" /></h1>
        <h2>Tracing as a Service</h2>

        <p>
            Spencer is an online service that lets you analyse large program
            traces of programs running on the JVM using custom queries.
            Queries in spencer are composable: If you have one analysis, you are
            able to refine it using others.
        </p>

        <h2>Queries</h2>

        <p>
            Queries in Spencer are expressions that return a set of object IDs.
            They implement a test: does an object's usage fulfill a certain
            definition or
            not?
        </p>

        <p>
            Spencer distinguishes between primitive queries and composed
            queries. Primitive queries are the basic building blocks that are
            implemented "natively" in the backend of the service.
        </p>

        <p>
            The primitive queries are:
        </p>

        <script>
            var COMMAND='query';
            var DBNAME='test';
        </script>

        <table style="width: 60%;" class="queries">
            <thead>
                <tr>
                    <td>Query</td>
                    <td class="empty"></td>
                    <td>Meaning</td>
                </tr>
            </thead>
            <tbody>
            @for(q <- QueryParser.primitiveQueries()) {
                <tr>
                    <td><div class="query">@q.toString</div></td>
                    <td>&mdash;</td>
                    <td><div class="queryExplanation">All objects that @(q.explanation).</div></td>
                </tr>
            }
            </tbody>
        </table>

        <p>
            Spencer's power lies in the fact that these queries all return the
            same kind of structure: sets of objects! This restriction makes it
            possible to compose queries into larger ones, like so:
        </p>

        <table style="width: 75%;" class="queries">
            <thead>
                <tr>
                    <th>Query</th>
                    <th class="empty"></th>
                    <th>Meaning</th>
                </tr>
            </thead>
            <tbody>
            @for(q <- List(
                "And(ImmutableObj() AllocatedAt(String.java:1933))",
                "Or(UniqueObj() ImmutableObj())",
                "Deeply(Or(UniqueObj() ImmutableObj()))",
                "ReachableFrom(AllocatedAt(String.java:1933))",
                "CanReach(AllocatedAt(String.java:1933))"
            )
                    .map(QueryParser.parseObjQuery)
                    .map(x => { assert(x.isRight, x+" must be right!"); x.right.get })) {
                <tr>
                    <td><div class="query">@q.toString</div></td>
                    <td>&mdash;</td>
                    <td><div class="queryExplanation">All objects that @(q.explanation).</div></td>
                </tr>
            }
            </tbody>
        </table>

        <p>
            Assembling queries from smaller parts is nice &mdash; but sometimes,
                you'll want to compare different queries with each other: how do
                prevalent are mutability, stationarity, and immutability, compared to
                each other? Comparing queries with each other can be done by separating
                several queries with a slash, like so:
                <span class="query">MutableObj()/StationaryObj()/ImmutableObj()</span>.
        </p>

        <p>
            These combined queries bring up an interactive visualisation, try
            clicking on the query name labels..
        </p>

        <h2>The design of Queries</h2>

        <h2>What's in the data?</h2>

        <p>
            Spencer contains many data sets. One data set is a program trace
            (in preprocessed form) that stems from running and instrumenting a
            program. The data in the program are distributed over several
            tables. Although these tables are not accessed directly by a user
            (they are accessed by the primitive queries instead), a user that
            wants to help Spencer grow must understand the data that they
            contain.
        </p>

        <h3>The <span class="code">objects</span> table</h3>

        <p>
            The objects table contains basic information on every object that
            was encountered during tracing. But see for yourself, below are a
            few records from our database. As you can see, we identify each
            object by its unique numeric ID, an object has an optional
            allocation site, it was created at a certain event ID, and we also
            record the last time the object was used (loaded, modified, read
            from, or called).
        </p>
        <p>
            You notice that there's one line with a negative ID. Those "objects"
            are pseudo objects that represent a class. Every access to static
            fields and methods will be reported as an access to this pseudo
            object in the rest of the data.
        </p>

        <p>
            You might also notice that the allocation sites are optional.
            This is a technical limitation: First, some class files do not
            contain location information and there is no line we could give.
            Second, some objects are created very early in the startup process,
            before the instrumentation is running. Third, some objects are
            allocated by native code -- and we do not instrument native code.
        </p>

        <div class="aside">
            <p>
                By the way these tables are interactive. Try hovering your mouse
                over the event indices. All earlier indices (with a lower
                number) will become red, all those later (with a higher number)
                will become green.<br/>

                Also, you may want to click one of the links next to object IDs
                or allocation sites. They will bring up the query system. Don't
                get lost there yet, though.
            </p>
        </div>

        <table>
            <thead>
                <tr>
                    <td>object id</td>
                    <td>allocation site?</td>
                    <td>event idx of allocation </td>
                    <td>event idx of last usage</td>
                </tr>
            </thead>
            <tbody>
                @for(rec <- (db.getFrame("objects").rdd.filter(_.getAs[Long]("id") < -500).take(1) ++ db.getFrame("objects").rdd.filter(_.getAs[Long]("id") > 1500).take(15)).sortBy(_.getAs[Long]("firstusage"))) {
                    <tr>
                        <td><span class="oid">@rec.getAs[Long]("id")</span></td>
                        <td>
                            @((Option(rec.getAs[String]("allocationsitefile")), Option(rec.getAs[Long]("allocationsiteline"))) match {
                                case (Some(f), Some(l)) => Html("<span class='sourceLocation allocationsite'>"+f+":"+l+"</span>")
                                case _ => Html("<span class='empty'>none</span>")
                            })
                        </td>
                        <td><span class="evtidx">@rec.getAs[Long]("firstusage")</span></td>
                        <td><span class="evtidx">@rec.getAs[Long]("lastusage")</span></td>
                    </tr>
                }
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
            </tbody>

        </table>

        <h3>The <span class="code">refs</span> table</h3>

        <p>
            The <span class="code">refs</span> table contains the "graph
            structure" of a program trace.
        </p>

        <p>
            References in this table are either variable- or field-references.
            References have a caller (the object holding the reference), a
            callee (the object being referenced, or <span class="oid">0</span>),
            they have a name (local variable names are not recorded, just
            numbered like <span class="code">var_{i}</span>).
        </p>

        <p>
            References also have a time of when they where established (by
            setting a field or variable, or passing a method argument) and a
            time when they where deleted (when overwriting a field or variable,
            for local variables when returning from a method call or for fields
            when an object is not used any longer.
        </p>

        <table>
            <thead>
                <tr>
                    <td><span class="code">caller</span></td>
                    <td class="empty"></td>
                    <td><span class="code">kind</span></td>
                    <td class="empty"></td>
                    <td><span class="code">name</span></td>
                    <td class="empty"></td>
                    <td><span class="code">callee</span></td>
                    <td class="empty"></td>
                    <td><span class="code">start</span></td>
                    <td class="empty"></td>
                    <td><span class="code">end</span>?</td>
                    <td class="empty"></td>
                    <td><span class="code">thread</span></td>
                </tr>
            </thead>
            <tbody>
                @for(rec <- (db.getFrame("refs").rdd.filter(row => row.getAs[String]("kind").equals("var"  ) && row.getAs[Long]("caller") > 1500).take(5) ++
                             db.getFrame("refs").rdd.filter(row => row.getAs[String]("kind").equals("field") && row.getAs[Long]("caller") > 1500).take(5)).sortBy(_.getAs[Long]("refstart"))) {
                    <tr>
                        <td><span class="oid">@rec.getAs[Long]("caller")</span></td>
                        <td style="padding: 0 1em;"><emph>holds a </emph></td>
                        <td><span class="code">@rec.getAs[String]("kind")</span></td>
                        <td style="padding: 0 1em;"><emph>ref called</emph></td>
                        <td><span class="code">@rec.getAs[String]("name")</span></td>
                        <td style="padding: 0 1em;"><emph>to</emph></td>
                        <td><span class="oid">@rec.getAs[Long]("callee")</span></td>
                        <td style="padding: 0 1em;"><i class="fa fa-clock-o"/></td>
                        <td><span class="evtidx">@rec.getAs[Long]("refstart")</span></td>
                        <td style="padding: 0 1em;">&mdash;</td>
                        <td>@Html(Option(rec.getAs[Long]("refend")).map("<span class='evtidx'>"+_+"</span>").getOrElse("<span class='empty'>none</span>"))</td>
                        <td style="padding: 0 1em;"><emph>established by</emph></td>
                        <td><span class="threadName">@rec.getAs[String]("thread")</span></td>
                    </tr>
                }
                <tr>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                </tr>
            </tbody>

        </table>

        <h3>The <span class="code">uses</span> table</h3>

        <p>
            Accesses to fields of objects end up in the
            <span class="code">uses</span> table. They are represented by events
                of kind <span class="code useKind">read</span> or
                <span class="code useKind">modify</span> for reads or writes of
                primitive type fields and
                <span class="code useKind">fieldload</span> or
                <span class="code useKind">fieldstore</span> for reads or
                writes of reference type fields. <emph>Reference type
                variables</emph> are treated as if they were fields that are
                exclusive to a method, they are represented by records of kind
                <span class="code useKind">varload</span>, or
                <span class="code useKind">varstore</span>, respectively.
                Variables of primitive types are not traced.
        </p>

        <table>
            <thead>
                <tr>
                    <td><span class="code">caller</span></td>
                    <td class="empty"></td>
                    <td><span class="code">kind</span></td>
                    <td class="empty"></td>
                    <td><span class="code">name</span></td>
                    <td class="empty"></td>
                    <td><span class="code">callee</span></td>
                    <td class="empty"></td>
                    <td><span class="code">idx</span></td>
                    <td class="empty"></td>
                    <td><span class="code">thread</span></td>
                </tr>
            </thead>
            <tbody>
                @for(rec <- (db.selectFrame("uses", "SELECT * FROM uses WHERE kind = 'modify'     AND caller > 1500 LIMIT 3") union
                             db.selectFrame("uses", "SELECT * FROM uses WHERE kind = 'fieldstore' AND caller > 1500 LIMIT 2") union
                             db.selectFrame("uses", "SELECT * FROM uses WHERE kind = 'fieldload'  AND caller > 1500 LIMIT 2") union
                             db.selectFrame("uses", "SELECT * FROM uses WHERE kind = 'varload'    AND caller > 1500 LIMIT 5") union
                             db.selectFrame("uses", "SELECT * FROM uses WHERE kind = 'varstore'   AND caller > 1500 LIMIT 2") union
                             db.selectFrame("uses", "SELECT * FROM uses WHERE kind = 'read'       AND caller > 1500 LIMIT 5")).sort(desc("idx")).collect) {
                    <tr>
                        <td><span class="oid">@rec.getAs[Long]("caller")</span></td>
                        <td style="padding: 0 1em;"><emph>executes</emph></td>
                        <td><span class="code useKind">@rec.getAs[String]("kind")</span></td>
                        <td style="padding: 0 1em;"><emph>of field</emph></td>
                        <td><span class="code">@rec.getAs[String]("name")</span></td>
                        <td style="padding: 0 1em;"><emph>of</emph></td>
                        <td><span class="oid">@rec.getAs[Long]("callee")</span></td>
                        <td style="padding: 0 1em;"><i class="fa fa-clock-o"/></td>
                        <td><span class="evtidx">@rec.getAs[Long]("idx")</span></td>
                        <td style="padding: 0 1em;"><emph>in</emph></td>
                        <td><span class="threadName">@rec.getAs[String]("thread")</span></td>
                    </tr>
                }
                <tr>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                </tr>
            </tbody>

        </table>

        <h3>The <span class="code">calls</span> table</h3>

        <p>
            Calls on objects are stored in the calls table. The calls table
            contains timing and thread information. Since calls are tagged with
            the event index of their start and end, we know that if two calls
            in the same thread are nested temporarily, they must also be nested
            on the call stack. The "apropos" view, accessible from object links
            <i class="fa fa-indent" aria-hidden="true"></i> exploits this for visulisation.
        </p>

        <p><emph>Hint:</emph> try brushing along the event indices in the
            <span class="code">start</span> column. The pattern in which the
        events in the <span class="code">end</span> column turn red tells you
        something about the call stack! Try to figure it out as an exercise :)
        </p>

        <table>
            <thead>
                <tr>
                    <td><span class="code">caller</span></td>
                    <td class="empty"></td>
                    <td><span class="code">name</span></td>
                    <td class="empty"></td>
                    <td><span class="code">callee</span></td>
                    <td class="empty"></td>
                    <td><span class="code">callsite</span></td>
                    <td class="empty"></td>
                    <td><span class="code">start</span></td>
                    <td class="empty"></td>
                    <td><span class="code">end</span></td>
                    <td class="empty"></td>
                    <td><span class="code">thread</span></td>
                </tr>
            </thead>
            <tbody>
                @for(rec <- db.selectFrame("calls", "SELECT * FROM calls WHERE thread = 'main' AND caller > 1500 ORDER BY callstart, callend LIMIT 10").collect()) {
                    <tr>
                        <td><span class="oid">@rec.getAs[Long]("callee")</span></td>
                        <td style="padding: 0 1em;"><emph>calls</emph></td>
                        <td><span class="code useKind">@rec.getAs[String]("name")</span></td>
                        <td style="padding: 0 1em;"><emph>on</emph></td>
                        <td><span class="oid">@rec.getAs[Long]("callee")</span></td>
                        <td style="padding: 0 1em;"><emph>at</emph></td>
                        <td><span class="sourceLocation">@Option(rec.getAs[String]("callsitefile")):@Option(rec.getAs[Long]("callsiteline"))</span></td>
                        <td style="padding: 0 1em;"><i class="fa fa-clock-o" aria-hidden="true"/></td>
                        <td><span class="evtidx">@rec.getAs[Long]("callstart")</span></td>
                        <td style="padding: 0 1em;">&mdash;</td>
                        <td><span class="evtidx">@rec.getAs[Long]("callend")</span></td>
                        <td style="padding: 0 1em;">in</td>
                        <td><span class="threadName">@rec.getAs[String]("thread")</span></td>
                    </tr>
                }
                <tr>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                    <td></td>
                    <td>...</td>
                </tr>
            </tbody>

        </table>

        <h3>Future Work: The <span class="code">sync</span> table</h3>

        <p>
            Event indices are numeric. This wrongly suggests that events are ordered
            by index, even accross threads. This is wrong because the fact that two
            parallel events ended up in the data base in one particular order does
            not imply that there was an actual happens-before relation.
        </p>
        <p>
            Spencer might, in the future, trace synchronisation points between
            threads that establishes happens-before accross thread boundaries.
        </p>

        <table>
            <thead>
                <tr>
                    <td><span class="code">sync1-thread</span></td>
                    <td><span class="code">sync1-file</span></td>
                    <td><span class="code">sync1-line</span></td>
                    <td><span class="code">sync1-event-before</span></td>
                    <td><span class="code">sync2-thread</span></td>
                    <td><span class="code">sync2-file</span></td>
                    <td><span class="code">sync2-line</span></td>
                    <td><span class="code">sync2-event-after</span></td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
            </tbody>
        </table>

    </div>

}

@import com.github.kaeluka.spencer.analysis.VertexIdAnalyser
@(dbname: String, queries: Seq[VertexIdAnalyser])

@main(queries.mkString(" / ")) {

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <style>
    #resultMatrix rect.matched {
        fill: #C83737;
    }

    .submitFocusWrapper {
        width: 15%;
        margin: 1em auto;
    }

    rect.rest {
        fill: #d9d9d9;
    }
    </style>

    <h1>Query</h1>

    <table class="queriesTable">
    @for((q, i) <- queries.zipWithIndex) {
        <tr>
            <td><i id="spinner-@i" class="fa fa-spinner fa-spin" aria-hidden="true"></i></td>
            <td><span class="query">@q</span> </td>
            <td><div class="queryExplanation">Objects that @q.explanation().</div></td>
        </tr>
    }
    </table>

    <script>
            var COMMAND = "query";
            var DBNAME  = "@dbname";
            var QUERIES = [@Html(queries.map("'"+_.toString+"'").mkString(", "))];
    </script>

    <div class="result">

        <div class="submitFocusWrapper">
            <a class="center" id="submitFocusLink" href="@routes.QueryController.query(dbname, queries.mkString("/"))">select focus objects <i class="fa fa-angle-right" aria-hidden="true"></i></a>
        </div>
        <svg id="resultMatrix"></svg>

        <div id="dataSetsContainer"></div>

        <div id="metaDataContainer">
            <i class="fa fa-spinner fa-spin" aria-hidden="true"></i>
        </div>

        <script>
                var color = randomColor({count: @(queries.size), seed: 123});
                var havePlot = {};

                var barLayouts = {};

                const enabledVariables = {};

                var allObjs = [];
                {
                    const req = new XMLHttpRequest();
                    req.open("GET", '@routes.QueryController.json_select(dbname, "Obj()")');
                    req.onload = (e) => {
                        allObjs = JSON.parse(req.responseText).objects;
                        requestAllData();
                    };
                    req.send(null);
                }

                var dataBuffer = {};
                var metaDataBuffer = { received: false };

                function requestAllData() {
                    const allObjsSet = new Set(allObjs);
                    @for((q, i) <- queries.zipWithIndex) {
                    {
                        dataBuffer["@q.toString"] = [];
                        const req = new XMLHttpRequest();
                        req.open("GET", "@routes.QueryController.json_select(dbname, q.toString)");
                        req.onload = function (e) {
                            console.log({req});
                            const resp = JSON.parse(req.responseText);
                            dataBuffer["@q.toString"] = resp.objects.filter(o => allObjsSet.has(o));
                            const spinner = document.getElementById("spinner-@i").parentNode.innerHTML = "<i class='fa fa-check' aria-hidden='true'></i>";
                            draw();
                        };
                        req.addEventListener("error", (e) => {
                            const spinner = document.getElementById("spinner-@i").parentNode.innerHTML = "<i class='fa fa-close' aria-hidden='true'></i>";
                        });
                        req.send(null);
                    }
                    }

                    {
                        const req = new XMLHttpRequest();
                        if (QUERIES.length > 1) {
                            req.open("GET", '@routes.QueryController.json_meta(dbname, queries.mkString("Or(", " ", ")"))');
                        } else {
                            req.open("GET", '@routes.QueryController.json_meta(dbname, queries(0).toString)');
                        }
                        req.onload = function (resp) {
                            metaDataBuffer = JSON.parse(req.responseText);
                            for (let v in metaDataBuffer.variables) {
                                if (metaDataBuffer.variables.hasOwnProperty(v)) {
                                    enabledVariables[v] = false;
                                }
                            }
                            metaDataBuffer.received = true;
                            draw();
                        };
                        req.send(null);
                    }
                    draw();
                }

                /**
                 * returns the query, accounting for the focus set -- as if the
                 * focus had been chosen. Use this for labeling data
                 */
                function projectFocusedQuery(query) {
                    const queryConstraints = [];
                    for (let inc of includeMatchList) {
                        queryConstraints.push(inc);
                    }

                    for (let hide of hideMatchList) {
                        queryConstraints.push("Not("+hide+")");
                    }

                    if (queryConstraints.length > 0) {
                        return "And(" + queryConstraints.join(" ") + " " + query + ")";
                    } else {
                        return query;
                    }
                }

                function drawNumericalVar(allData, variable) {
                    const data = allData[variable];
                    const div = document.getElementById("numerical-div-"+variable);

                    const boxPlotData = [];
                    for (let q in data) {
                        if (data.hasOwnProperty(q)) {
                            boxPlotData.push({
                                type: "histogram",
                                name: projectFocusedQuery(q),
                                x: data[q].y // yes, this SHOULD assign y to x -.-
                            })
                        }
                    }

                    const layout = {
                        autosize: true,
                        font: {
                            size: 20
                        },
                        title: "Histogram: "+variable+" of objects",
                        width: 1000,
                    };
                    Plotly.newPlot(div, boxPlotData, layout);
                }

                function drawCategoricalVar(allData, variable) {
                    let maxY = - Infinity;
                    const bardata = [];
                    for (let query in allData[variable]) {
                        if (allData[variable].hasOwnProperty(query)) {
                            const dataset = allData[variable][query];
                            let xs = [];
                            let ys = [];
                            for (let x in dataset) {
                                if (dataset.hasOwnProperty(x)) {
                                    xs.push(x);
                                    let y = dataset[x];
                                    ys.push(dataset[x]);
                                    if (y > maxY) {
                                        maxY = y;
                                    }
                                }
                            }

                            function sortedData(xs, ys) {
                                xys = [];
                                for (let i=0; i<xs.length; ++i) {
                                    const x = xs[i];
                                    const y = ys[i];
                                    xys.push({x, y})
                                }

                                xys.sort((a,b) => b.y - a.y);
                                if (QUERIES.length > 1) {
                                    xys = xys.slice(0, 30)
                                }

                                xs = [];
                                ys = [];

                                for (let xy of xys) {
                                    xs.push(xy.x);
                                    ys.push(xy.y);
                                }

                                return {
                                    xs, ys
                                }
                            }

                            //FIXME: we need to sort ALL data groups together, no?!
                            xsys = sortedData(xs, ys);
                            xs = xsys.xs;
                            ys = xsys.ys;

                            bardata.push({
                                x: xs,
                                y: ys,
                                type: 'bar',
                                mode: 'lines',
                                hoverinfo: 'y',
                                name: projectFocusedQuery(query),
//                                opacity: 0.08,
//                                marker: {
//                                    color: 'red',
//                                    line: {
//                                        color: 'black',
//                                        width: 2
//                                    }
//                                }
                            });


                        }
                    }

                    if (! barLayouts.hasOwnProperty(variable)) {
                        barLayouts[variable] = {
//                            barmode: 'stack',
                            autosize: false,
                            font: {
                                size: 20
                            },
                            title: 'Number of objects per '+variable,
                            height: 300,
                            width: Math.min(1000, bardata[bardata.length-1].y.length*30 + 500),
                            yaxis: { range : [0, maxY*1.05] }
                        };

                        if (variable === 'klass' || variable === 'allocationSite') {
                            //todo
                            barLayouts[variable].margin = {
                                b: 600
                            };
                            barLayouts[variable].height += barLayouts[variable].margin.b;
                        } else if (variable === 'connectedComponent') {
                            barLayouts[variable].margin = {
                                b: 200
                            };
                            barLayouts[variable].height += barLayouts[variable].margin.b;
                        }
                    }
                    const barlayout = barLayouts[variable];
                    const chartId = "categorical-div-"+variable;

                    const chart = document.getElementById(chartId);
                    if (havePlot.hasOwnProperty('variable') && havePlot[variable] == true) {
                        chart.data = bardata;

                        Plotly.redraw(chart)
                    } else {
                        Plotly.newPlot(chart, bardata, barlayout);
                        havePlot[variable] = true;
                    }
                }

                /**
                 * Returns the data, projected:
                 * if a query is in focusMatch, then only objects that match the query will be returned,
                 * if a query is in focusNonmatch, then only objects that do NOT match the query will be returned
                 *
                 * param focusMatch
                 * param focusNonmatch
                 * returns {{sizes: Array, queries: Array, explanations: Array, data: Array, totalFocused: Number}}
                 */
                function getRawData(focusMatch, focusNonmatch) {
                    const N = @queries.length;
                    const queries = [];
                    const explanations = [];
                    const sizes = [];
                    const data = [];

                    @for(q <- queries) {
                    {
                        /////@(q.toString)
                        let query = "@q.toString";
                        queries.push("@(q.toString)");
                        explanations.push("Objects that @(q.explanation).");

                        data[query] = {
                            pass: undefined,
                            fail: undefined
                        };

                        data[query].pass = dataBuffer[query];

                        let querySet = new Set(data[query].pass);
                        data[query].fail = allObjs.filter(o => ! querySet.has(o));

                        console.log("out of "+allObjs.length+" objects: ");
                        console.log("query "+query+" has "+data[query].pass.length+" passes, "+data[query].fail.length+" failures");

                        console.log({
                            pass: data[query].pass,
                            querySet,
                            fail: data[query].fail
                        });
                    }
                    }

                    let excludedObjs = [];

                    for (m of focusMatch){
                        console.log("focusing on passes of "+m);
                    }
                    for (m of focusNonmatch){
                        console.log("focusing on failures of "+m);
                    }

                    for (let q of focusMatch) {
                        excludedObjs = excludedObjs.concat(data[q].fail);
                    }

                    for (let q of focusNonmatch) {
                        excludedObjs = excludedObjs.concat(data[q].pass);
                    }
                    excludedObjs = new Set(excludedObjs);
                    console.log("excluding "+excludedObjs.size+" objects");

                    for (let i in data) {
                        data[i].pass = data[i].pass.filter(oid => ! excludedObjs.has(oid));
                        data[i].fail = data[i].fail.filter(oid => ! excludedObjs.has(oid));
                    }

                    for (let i in data) {
                        var size_row = [];
                        var iSet = new Set(data[i].pass);
                        for (let j in data) {
                            let f = data[j].pass.filter((oid) => iSet.has(oid));
                            size_row.push(
                                    f.length
                            );
                        }
                        console.log(size_row+" - "+i);
                        sizes.push(size_row);
                    }

                    return {
                        sizes: sizes,
                        queries: queries,
                        explanations: explanations,
                        data: data,
                        totalFocused: allObjs.length - excludedObjs.size
                    };
                }

                const boxSize = 100;
                const boxMargin = 10;
                var includeMatchList = new Set([]);
                var hideMatchList = new Set([]);

                function draw() {
                    const data = getRawData(includeMatchList, hideMatchList);

                    drawMatrix(data);
                    drawTable(data);
                    addHints();
                    if (metaDataBuffer.received) {
                        drawMetaData(data);
                    }
                }

                function getBarData(data) {
                    const barData = {
                        variables: {
                            categorical: [],
                            ordinal: [],
                            numerical: [],
                            all: []
                        }
                    };
                    for (let v in metaDataBuffer.variables) {
                        if (metaDataBuffer.variables.hasOwnProperty(v)) {
                            barData.variables[metaDataBuffer.variables[v]].push(v);
                            barData.variables.all.push(v);
                        }
                    }

                    /**
                     * mappedBarData shall contain:
                     * for each categorical variable,
                     *   for each query,
                     *     for each value of the variable,
                     *       the number of objects that pass the query and have that value
                     */
                    for (let v of barData.variables.all) {
                        barData[v] = {};
                        for (let q of QUERIES) {
                            if(metaDataBuffer.variables.hasOwnProperty(v)) {
                                barData[v][q] = {};
                            }
                        }
                    }
                    // for each variable, go through metaDataBuffer.objects
                    // and
                    for (let query of QUERIES) {
                        const qSet = new Set(data.data[query].pass);
                        for (let metaDataObject of metaDataBuffer.objects) {
                            for (let variable of barData.variables['categorical']) {
                                if (!barData[variable][query].hasOwnProperty(metaDataObject[variable])) {
                                    barData[variable][query][metaDataObject[variable]] = 0;
                                }
                                if (qSet.has(metaDataObject.oid)) {
//                                    if (metaDataObject.hasOwnProperty(variable)) {
//                                        debugger;
                                        barData[variable][query][metaDataObject[variable]] += 1;
//                                    }
                                }
                            }
                        }
                    }

                    // NUMERICAL DATA
                    for (let q of QUERIES) {
                        const qSet = new Set(data.data[q].pass);
                        for (let v of barData.variables['numerical']) {
                            barData[v][q] = {x: [], y: []};
                            for (let o of metaDataBuffer.objects) {
                                if (o.hasOwnProperty(v)) {
                                    if(qSet.has(o.oid)) {
                                        barData[v][q].x.push(o.oid);
                                        barData[v][q].y.push(o[v]);
                                    }
                                }
                            }
                        }
                    }
                    //FIXME: derive data, like the numerical classPercent, allocationSitePercent, fieldPercent, ...
                    return barData;
                }

                function drawMetaData(data) {
                    console.log({metaDataBuffer});
                    document.getElementById("metaDataContainer").innerHTML = '';

                    const container = d3.select("#metaDataContainer");

                    const barData = getBarData(data);
                    console.log({barData});

                    function toggleVariable(data) {
                        return function (v) {
                            console.log("toggling "+v);
                            if (enabledVariables[v]) {
                                document.getElementById("toggle-variable-icon-"+v)
                                        .setAttribute("class", "fa fa-angle-down")
                            } else {
                                document.getElementById("toggle-variable-icon-"+v)
                                        .setAttribute("class", "fa fa-angle-up")
                            }
                            enabledVariables[v] = ! enabledVariables[v];
                            drawMetaData(data)
                        }
                    }

                    const perVariableMetaInfo = container
                            .append("h2")
                            .text("Object Variables")
                            .append("div")
                            .attr("class", "perVariableMetaInfo");

                    perVariableMetaInfo
                            .append("div")
                            .selectAll("div")
                            .data(barData.variables['categorical'])
                            .enter()
                            .append("div")
                            .attr("class", "variable-div")
                            .append("h3")
                            .on("click", toggleVariable(data))
                            .html(function(v) {
                                if (enabledVariables[v]) {
                                    return '<i id="toggle-variable-icon-'+v+'" class="fa fa-angle-up"   aria-hidden="true"></i> '+v
                                } else {
                                    return '<i id="toggle-variable-icon-'+v+'" class="fa fa-angle-down" aria-hidden="true"></i> '+v
                                }})
                            .append("div")
                            .attr("id", v => "categorical-div-"+v);

                    perVariableMetaInfo
                            .append("div")
                            .selectAll("div")
                            .data(barData.variables['numerical'])
                            .enter()
                            .append("div")
                            .attr("class", "variable-div")
                            .append("h3")
                            .on("click", toggleVariable(data))
                            .html(function(v) {
                                if (enabledVariables[v]) {
                                    return '<i id="toggle-variable-icon-'+v+'" class="fa fa-angle-up"   aria-hidden="true"></i> '+v
                                } else {
                                    return '<i id="toggle-variable-icon-'+v+'" class="fa fa-angle-down" aria-hidden="true"></i> '+v
                                }})
                            .append("div")
                            .attr("id", v => "numerical-div-"+v)
                            ;

                    for (let v of barData.variables['categorical']) {
                        if (enabledVariables[v]) {
                            drawCategoricalVar(barData, v);
                        }
                    }

                    for (let v of barData.variables['numerical']) {
                        console.log("######### NUMERICAL VARIABLE "+v);
                        if (enabledVariables[v]) {
                            drawNumericalVar(barData, v);
                        }
                    }
                }

                function drawTable(data) {
                    document.getElementById("dataSetsContainer").innerHTML = '';
                    const dataSetsContainer = d3.select("#dataSetsContainer");
                    const newDivs = dataSetsContainer
                            .selectAll("div")
                            .data(QUERIES)
                            .enter()
                            .append("div");
                    newDivs
                            .append("h3")
                            .text(d => d);

                    newDivs
                            .append("div")
                            .html(function (q) {
                                let d = data.data[q].pass;
                                const NMAX = 100;
                                if (d.length > NMAX) {
                                    return d.slice(0, NMAX-1)
                                                    .map(oid => "<span class='oid'>"+oid+"</span>")
                                                    .join(", ")+" and "+(d.length - NMAX)+" more.."
                                } else {
                                    return d
                                            .map(oid => "<span class='oid'>"+oid+"</span>")
                                            .join(", ")
                                }
                            });
                }

                function drawMatrix(data) {
                    const N = @queries.size; //number of queries
                    const margin = {top: 0, bottom: 100, left: 200, right: 200};

                    const svg = d3.select("#resultMatrix")
                            .attr("width", (N)*boxSize+margin.left+margin.right)
                            .attr("height", (N)*boxSize+margin.bottom+margin.top);
                    const grid = svg.append("g")
                            .attr("transform", "translate("+margin.left+","+margin.top+")")
                            .attr("width", +svg.attr("width")-margin.left-margin.right)
                            .attr("height", +svg.attr("height")-margin.top-margin.bottom);
                    grid.selectAll(".gridCell").remove();

                    var gridData = [];

                    for (let i in data.sizes) {
                        for (j in data.sizes) {
                            gridData.push({
                                i: i,
                                j: j,
                                size: data.sizes[i][j]
                            });
                        }
                    }

                    const maxSize = data.totalFocused;

                    const sz = d3.scaleLinear()
                            .domain([0, maxSize])
                            .range([0, boxSize - boxMargin]);

                    var cells = grid.selectAll("g")
                            .data(gridData)
                            .enter()
                            .append("g")
                            .attr("class", "gridCell");

                    cells.attr("transform", function (d) {
                        return "translate("+(d.i*boxSize)+","+(d.j*boxSize)+")";
                    });

                    cells.append("rect")
                            .attr("class", "rest")
                            .attr("width",  boxSize - boxMargin)
                            .attr("height", boxSize - boxMargin)
                            //FIXME: use this handler :)
                            .on("click", (fail, i) => console.log({fail}));

                    cells.append("rect")
                            .attr("height",    (d) => sz(d.size))
                            .attr("transform", (d) => "translate(0, "+(boxSize - boxMargin - sz(d.size))+")")
                            .attr("width", (d) => boxSize - boxMargin )
                            .attr("class", function(d) {
                                if (d.i === d.j) {
                                    return "matched objectsRect"+d.i;
                                } else {
                                    return "matched";
                                }
                            })
                            //FIXME: use this handler :)
                            .on("click", (pass, i) => console.log({pass}) );
                    cells.append("text")
                            .attr("height",    boxSize - boxMargin)
                            .attr("transform", function(d) {
                                return "translate("+(boxSize / 2 - 5)+", "+Math.max(10, (boxSize - 13 - sz(d.size)))+")";
                            })
                            .attr("class", "percentage")
                            .attr("text-anchor", "middle")
//                            .text((d) => d.size+" - "+Math.round(100*d.size/data.totalFocused)+"%");
                            .text((d) => Math.round(100*d.size/data.totalFocused)+"%");

                    // legend:
                    svg.selectAll("text.legendBottom")
                            .data(data.queries)
                            .enter()
                            .append("text")
                            .attr("class", (d, i) => "legendBottom legend"+i)
                            .attr("text-anchor", "middle")
                            .attr("transform",
                                    (d, i) =>
                                    "translate("+(margin.left+i*boxSize+boxSize/2)+","+
                                    (margin.top + boxSize*N+margin.bottom/2)+") rotate(-10)" )
                            .text((d, i) => d)
                            .on("click",     clickHandler      )
                            .on("mouseover", mouseOverHandler )
                            .on("mouseout",  mouseOutHandler   );

                    svg.selectAll("text.legendLeft")
                            .data(data.queries)
                            .enter()
                            .append("text")
                            .attr("class", (d, i) => "legendLeft legend"+i)
                            .attr("text-anchor", "end")
                            .attr("dy", "0.35em")
                            .attr("transform", (d, i) => "translate("+margin.left+","+(margin.top+i*boxSize+boxSize/2)+")" )
                            .text((d, i) => d)
                            .on("click",     clickHandler      )
                            .on("mouseover", mouseOverHandler )
                            .on("mouseout",  mouseOutHandler   );

                    // "loading" symbols:
                    cells.append("i")
                            .attr("class", "fa fa-spinner");

                }


                function clickHandler(d, i) {
                    console.log("click " + i);
                    if (includeMatchList.has(QUERIES[i])) {
                        includeMatchList.delete(QUERIES[i]);
                        hideMatchList.add(QUERIES[i]);
                        $(".legend" + i).css("fill", "#d9d9d9");
                    } else if (hideMatchList.has(QUERIES[i])) {
                        hideMatchList.delete(QUERIES[i]);
                        $(".legend" + i).css("fill", "black");
                    } else {
                        includeMatchList.add(QUERIES[i]);
                        $(".legend" + i).css("fill", "#C83737");
                    }


                    const queryConstraints = [];
                    for (let inc of includeMatchList) {
                        queryConstraints.push(inc);
                    }
                    for (let hide of hideMatchList) {
                        queryConstraints.push("Not("+hide+")");
                    }

                    if(queryConstraints.length != 0) {
                        let newQueries = QUERIES
                                .filter(q => (! includeMatchList.has(q)) && (! hideMatchList.has(q)));
                        function constrainQuery(q) {
                            return "And(" + queryConstraints.join(" ") + " " + q + ")";
                        }
                        const baseURL = "/query/@dbname/";
                        let newQueriesURL = baseURL+(newQueries.map(constrainQuery).join("/"));
                        d3.select("#submitFocusLink").attr("href", newQueriesURL);
                    }

                    draw();
                }

                function mouseOverHandler(d, i) {
                    $(".matched").css("fill", "C0C0C0");
                    $(".objectsRect"+i).css("fill", "#EE4343");
                }

                function mouseOutHandler(d, i) {
                    $(".matched").css("fill", "#C83737");
                }
        </script>

    </div>

    <div class="footer">
        <ul id="jsonLinks">
        </ul>
    </div>

    <script>
        let allObjsSelection = "@(routes.QueryController.json_select(dbname, "Obj()"))";
        let allObjsMeta = "@(routes.QueryController.json_meta(dbname, "Obj()"))";
        d3.select("#jsonLinks")
                .selectAll("li")
                .data(QUERIES)
                .enter()
                .append("li")
                .append("a")
                .html(function(d,i) {
                    let regex = new RegExp("Obj\(\)");
                    let url = allObjsSelection.replace(regex, d);
                    return "<a href='"+url+"' download>"+d+" (JSON)</a>";
                });
        d3.select("#jsonLinks")
                .append("li")
                .append("a")
                .attr("href", allObjsMeta)
                .text("Meta information (JSON)")
    </script>
}
